# -*- coding: utf-8 -*-
"""Untitled20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zKMmGmu-cmaxY3hXFEMXbXX8t0v38fVf
"""

!pip install pyswarm



import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from pyswarm import pso
from mpl_toolkits.mplot3d import Axes3D

# Define material/job-based multipliers (example dictionary)
material_factors = {
    'Aluminum': {'ra_factor': 1.0, 'time_factor': 1.0},
    'Mild Steel': {'ra_factor': 1.1, 'time_factor': 1.2},
    'Titanium': {'ra_factor': 1.3, 'time_factor': 1.5},
    'Brass': {'ra_factor': 0.9, 'time_factor': 0.95}
}

# Interactive material selection
def select_material():
    print("Select Material:")
    for idx, material in enumerate(material_factors.keys()):
        print(f"{idx + 1}. {material}")
    selection = int(input("Enter the number corresponding to your material: ")) - 1
    selected_material = list(material_factors.keys())[selection]
    return selected_material, material_factors[selected_material]['ra_factor'], material_factors[selected_material]['time_factor']

selected_material, ra_factor, time_factor = select_material()

# Define surface roughness and machining time estimation functions
def surface_roughness(x):
    Vc, f, d = x
    base_ra = 0.032 * (Vc**-0.26) * (f**0.68) * (d**0.42)
    return base_ra * ra_factor

def machining_time(x):
    Vc, f, d = x
    L = 100  # Tool path length in mm
    base_time = L / (Vc * f)
    return base_time * time_factor

def tool_wear_rate(Vc, f, material):
    base_twr = 0.001 * (Vc**0.5) * (f**0.4)
    material_factor = {'Aluminum': 1.0, 'Mild Steel': 1.2, 'Titanium': 1.5}
    return base_twr * material_factor[material]

def cutting_force(Vc, f, d):
    k = 100  # constant for material-dependent cutting force coefficient
    return k * Vc * f * d

def vibration_index(Vc, f, d):
    return 1 / (Vc * f * d)

def power_consumption(Fc, machine_efficiency=0.85):
    return Fc * machine_efficiency

def surface_integrity(Ra, TWR):
    return Ra * (1 + TWR)

# Tool/machine limits (constraints)
def constraints(x):
    Vc, f, d = x
    max_cutting_force = 2000  # hypothetical max force in N
    max_power = 10  # kW
    force = cutting_force(Vc, f, d)
    power = power_consumption(force)
    return force < max_cutting_force and power < max_power

# Objective function (weighted sum)
def extended_objective(x):
    Vc, f, d = x
    Ra = surface_roughness(x)
    T = machining_time(x)
    TWR = tool_wear_rate(Vc, f, selected_material)
    Fc = cutting_force(Vc, f, d)
    Vi = vibration_index(Vc, f, d)
    P = power_consumption(Fc)
    SI = surface_integrity(Ra, TWR)

    w1, w2, w3, w4, w5, w6, w7 = 0.2, 0.2, 0.2, 0.15, 0.1, 0.05, 0.1
    return w1 * Ra + w2 * T + w3 * TWR + w4 * Fc + w5 * Vi + w6 * P + w7 * SI

# Bounds for Vc, f, and d
lb = [100, 0.05, 0.5]
ub = [300, 0.3, 2.0]

# Record objective values and parameters for visualization
objective_history = []
position_history = []
parameters_history = {
    "Ra": [], "T": [], "TWR": [], "Fc": [], "Vi": [], "P": [], "SI": []
}

def logging_objective(x):
    Vc, f, d = x
    Ra = surface_roughness(x)
    T = machining_time(x)
    TWR = tool_wear_rate(Vc, f, selected_material)
    Fc = cutting_force(Vc, f, d)
    Vi = vibration_index(Vc, f, d)
    P = power_consumption(Fc)
    SI = surface_integrity(Ra, TWR)

    val = extended_objective(x)
    objective_history.append(val)
    position_history.append(x.copy())
    parameters_history["Ra"].append(Ra)
    parameters_history["T"].append(T)
    parameters_history["TWR"].append(TWR)
    parameters_history["Fc"].append(Fc)
    parameters_history["Vi"].append(Vi)
    parameters_history["P"].append(P)
    parameters_history["SI"].append(SI)

    return val

# Run PSO with custom objective logging
best_pos, best_val = pso(logging_objective, lb, ub, swarmsize=30, maxiter=100, debug=True)

print("\nMaterial Selected:", selected_material)
print("Optimal Parameters:")
print(f"Cutting Speed (Vc): {best_pos[0]:.2f} m/min")
print(f"Feed Rate (f): {best_pos[1]:.3f} mm/rev")
print(f"Depth of Cut (d): {best_pos[2]:.2f} mm")
print(f"Objective Value: {best_val:.5f}")

# Save results to CSV
results_df = pd.DataFrame(position_history, columns=["Vc", "f", "d"])
results_df = results_df.assign(**parameters_history)
results_df["Objective"] = objective_history
results_df.to_csv("pso_cnc_optimization_results.csv", index=False)

# Plotting the convergence graph
def plot_convergence(objective_history):
    plt.figure(figsize=(10, 5))
    plt.plot(objective_history, label='Objective Value')
    plt.title('PSO Convergence for CNC Optimization')
    plt.xlabel('Iteration')
    plt.ylabel('Objective Function Value')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

plot_convergence(objective_history)

# 3D scatter plot of parameter space with objective value
def plot_3d_parameter_space(position_history, objective_history):
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')
    vc_vals = [p[0] for p in position_history]
    f_vals = [p[1] for p in position_history]
    d_vals = [p[2] for p in position_history]
    obj_vals = objective_history

    surf = ax.scatter(vc_vals, f_vals, d_vals, c=obj_vals, cmap='viridis')
    ax.set_xlabel('Cutting Speed Vc (m/min)')
    ax.set_ylabel('Feed Rate f (mm/rev)')
    ax.set_zlabel('Depth of Cut d (mm)')
    ax.set_title('3D Scatter of Parameter Space with Objective Value')
    fig.colorbar(surf, ax=ax, shrink=0.5, aspect=5, label='Objective Value')
    plt.tight_layout()
    plt.show()

plot_3d_parameter_space(position_history, objective_history)

# Additional subplots for each parameter
def plot_parameters(parameters_history, objective_history):
    fig, axes = plt.subplots(nrows=4, ncols=2, figsize=(15, 12))
    axes = axes.flatten()
    params = {
        "Ra": "Surface Roughness (Ra)",
        "T": "Machining Time (T)",
        "TWR": "Tool Wear Rate (TWR)",
        "Fc": "Cutting Force (Fc)",
        "Vi": "Vibration Index (Vi)",
        "P": "Power Consumption (P)",
        "SI": "Surface Integrity (SI)"
    }

    for i, (key, label) in enumerate(params.items()):
        axes[i].plot(parameters_history[key], label=label)
        axes[i].set_title(label)
        axes[i].set_xlabel('Iteration')
        axes[i].set_ylabel(label)
        axes[i].legend()
        axes[i].grid(True)

    plt.tight_layout()
    plt.show()

plot_parameters(parameters_history, objective_history)